{"meta":{"title":"李鹏的个人博客","subtitle":"","description":"李鹏的个人博客","author":"李鹏","url":"http://yoursite.com","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-06-01T10:12:24.740Z","updated":"2020-06-01T10:12:24.740Z","comments":false,"path":"/404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2020-06-02T14:24:36.376Z","updated":"2020-06-02T14:24:36.376Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"个人详细介绍 ​ 各位大佬大家好，我叫李鹏，来自四川广安，今年20岁，也是标准的00后，虽然长相和年龄和不符合，所以这里就不展示本人照片了，由于我刚刚从学校毕业，没有什么经验，也只能分享一点自己平时做的笔记，希望能帮助到大家，也希望大家能指出我的错误，非常感谢！"},{"title":"书单","date":"2020-06-01T10:12:24.746Z","updated":"2020-06-01T10:12:24.746Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-06-01T11:44:32.656Z","updated":"2020-06-01T11:44:32.656Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-06-01T10:12:24.749Z","updated":"2020-06-01T10:12:24.749Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-06-01T11:46:31.549Z","updated":"2020-06-01T11:46:31.549Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-06-01T10:12:24.748Z","updated":"2020-06-01T10:12:24.748Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"vue基础知识","slug":"vue基础知识","date":"2020-06-06T09:27:47.941Z","updated":"2020-06-06T09:32:41.201Z","comments":true,"path":"2020/06/06/vue基础知识/","link":"","permalink":"http://yoursite.com/2020/06/06/vue%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"Vue的基础1.入门示例1.1、安装A.在开发初期，我们只需要使用cdn嵌入方式，并且格式 不能是压缩格式(指min)，因为压缩格式在开发初期不会提示错误，对初学者不利1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt; B.NPM安装12# 最新稳定版$ npm install vue 1.2、第一个Vue项目12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;!-- 利用插值语法插入Vue实例中data的数据 --!&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue.js!' &lt;!-- 将message的数据在页面显示出来 --!&gt; &#125;&#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 12展示结果 Hello Vue.js 2.内部指令2.1 插值语法 ———&gt; 、v-html、v-text、v-clockA.123&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;/div&gt; B. v-html 可以解析html标签，类似于innerHTML123456789101112&lt;div id=\"app\"&gt; &lt;div v-html=\"message\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: '&lt;h1&gt;得玛西亚&lt;/h1&gt;' &#125;&#125;)&lt;/script&gt; C. v-text 不能解析html标签，类似于innerText123456789101112&lt;div id=\"app\"&gt; &lt;div v-text=\"message\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: '得玛西亚' &#125;&#125;)&lt;/script&gt; D. v-cloak 防止闪烁，当网速较慢时实例未生成出现原标签123456789解决方案： &lt;style&gt; [v-cloak] &#123; display: none; &#125; &lt;/style&gt; &lt;div v-cloak&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; 2.2、条件指令 ——-&gt; v-if,v-else,v-else-if,v-showA. v-if,v-else,v-else-if一般连用1234567891011121314151617181920212223&lt;div id=\"app\"&gt; &lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; type: 'C' &#125; &#125;)&lt;/script&gt; B. v-show —-动态显示与隐藏123456789&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; ok: 'true' &#125;&#125;)&lt;/script&gt; 注意： v-if与v-show的区别 ​ v-if是动态的创建与删除，切换开销很大，如果需要非常频繁的切换就使用v-show ​ ** v-show是动态的显示与隐藏，初始话开销很大，如果运行条件很少改变就使用v-if ** 2.3 循环指令 ——–&gt; v-forv-for类似于原生js的for循环 可以对对象，数组，整数进行迭代语法形式：v-for=”(第一个参数, 第二个参数, 第三个参数) in 迭代数据” 第一个参数：一条一条的数据的显示 第二个参数：对象时是键名，其他为索引 第三个参数：索引值 注：可以只写一个参数或多个参数，再用v-for循环时最好时动态绑定一个key值，防止重名之内,key值必须是一个唯一值，不能重复 1234567891011121314&lt;ul id=\"example-1\"&gt; &lt;li v-for=\"item in items\" :key=\"item.message\"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt;var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) 2.4 动态绑定事件与属性 —&gt; v-on(@),v-bind(:)A： v-on动态绑定事件，原生js的事件都能绑定，不用加on(click,mousedown)，简写 @​ 注意： ​ 1.当事件不加小括号时，默认传递参数$event，在函数中定义实参可以获得， ​ 2.如果事件加了小括号没有传递参数就没有事件对象，加了小括号必须要传递一个参数$event,函数中才能拿到事件对象 事件修饰符1234567891011121314a.&lt;!-- 阻止单击事件冒泡 --&gt; &lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;b.&lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;c.&lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;d.&lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt;e.&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt; &lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;f.&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt; &lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;g.&lt;!-- click 事件只能点击一次，2.1.4版本新增 --&gt; &lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 按键修饰符—可以根据ascll码值找到对应的按键例如：&lt;input v-on:keyup.ascll码值(例如13)=”submit”&gt; 1234567891011121314常用键的别名: .enter .tab .delete (捕获 \"删除\" 和 \"退格\" 键) .esc .space .up .down .left .right .ctrl .alt .shift .meta B： v-bind动态绑定属性，如果属性的值是动态的需要使用v-bind绑定属性使其解析变量，简写 :​ （1）绑定css和style ​ 都可以使用数组语法与对象语法，例如： 12345678910//动态绑定外部类名---对象方法v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"//数组方法&lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt;//动态绑定内联样式---对象方法&lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;\"&gt;&lt;/div&gt;//数组方法&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt;//三元表达式切换样式&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt; 2.5 双向数据绑定 —-&gt; v-modelA： v-model监控表单的数据，数据随表单的数据变化而变化（1）input 1&lt;input type=\"text\" v-model=\"message\"&gt; （2）textarea 1&lt;textarea cols=\"30\" rows=\"10\" v-model=\"message\"&gt;&lt;/textarea&gt; （3）checkbox 12345&lt;input type=\"checkbox\" id=\"first\" value=\"1\" v-model=\"status\"&gt;&lt;label for=\"first\"&gt;有效&lt;/label&gt;&lt;input type=\"checkbox\" id=\"second\" value=\"2\" v-model=\"status\"&gt;&lt;label for=\"second\"&gt;无效&lt;/label&gt;&lt;div&gt;状态：&#123;&#123;status&#125;&#125;&lt;/div&gt; （4）radio 12345&lt;input type=\"radio\" id=\"one\" value=\"男\" v-model=\"sex\"&gt;&lt;label for=\"one\"&gt;男&lt;/label&gt;&lt;input type=\"radio\" id=\"two\" value=\"女\" v-model=\"sex\"&gt;&lt;label for=\"one\"&gt;女&lt;/label&gt;&lt;div&gt;性别：&#123;&#123;sex&#125;&#125;&lt;/div&gt; （5）select 1234567&lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt;&lt;/select&gt;&lt;div&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/div&gt; 注：v-model绑定的数据需要在data中提前定义好的 B：表单中的修饰符​ （1）: .lazy 在默认情况下， v-model 在 input 事件中同步输入框的值与数据，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步： 12&lt;!-- 在 \"change\" 而不是 \"input\" 事件中更新 --&gt; &lt;input v-model.lazy=\"msg\" &gt; ​ （2）: .number 将用户输入的值转换为数值型，但是如果转换的为NAN即返回原值,则这个并没有啥用，还没有将type变为number有用 1&lt;input v-model.number=\"age\" type=\"number\"&gt; ​ （3）: .trim 将=自动过滤用户输入的首尾空格 1&lt;input v-model.trim=\"msg\"&gt; 3.计算属性A：定义：主要是对原数据进行改造输出，并且可以复用。改造输出：包括格式化数据（价格，日期），大小写转换，排序，添加符号B：作用：computed比较适合对多个变量或者对象进行处理后返回一个结果值，也就是数多个变量中的某一个值发生了变化则我们监控的这个值也就会发生变化，例如：购物车里面的商品列表和总金额之间的关系，只要商品列表里面的商品数量发生变化，或减少或增多或删除商品，总金额都应该发生变化。C：例子：123456789101112131415161718192021&lt;div id=\"app\"&gt; &lt;p&gt;原始字符串: &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;p&gt;计算后反转字符串: &#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125; &#125;)&lt;/script&gt; // 实时监听计算属性中的值是否变，如果变化，计算属性的值也会变化 4.过滤器A：定义：Vue.js 允许自定义过滤器，可被用于一些常见的文本格式化，过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 (后者从 2.1.0+ 开始支持)。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符号指示B：全局过滤器定义，在Vue实例之前定义Vue.filter(),语法格式：Vue.filter(‘过滤器名称’,{return 需要替换的结果})12345678910例： Vue.filter('capitalize', function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) // 首字母大写 &#125;) new Vue(&#123; // ... &#125;) C：局部过滤器定义，在vue实例中使用filters(‘过滤器名称’,{return 结果})12345678例： filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125; D：如何使用，语法： 需要过滤的数据 | 过滤器名称​ 注意： ​ 1.当全局过滤器和局部过滤器重名时，会采用局部过滤器 ​ 2.在使用过滤器时，如果多个过滤器，如： ，运行规则是A过滤message中的数据，B过滤filterA过滤完的数据 ​ 3.过滤器也可以接受参数，在定义过滤器时接受参数，做自己想做的操作，如: 1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 5.生命周期 1234567891011121314151617181920212223242526272829303132333435363738394041424344代码示例：&lt;script&gt; const vm = new Vue(&#123; el:'#app', data:&#123; msg:'大家好！', &#125;, // create阶段 // 1.beforeCreate表示组件实例刚被创建，还没实例化对象之前，执行一些初始化操作 beforeCreate() &#123; console.log(\"我是beforeCreate \" + this.msg) &#125;, // 2.created表示组件实例创建完成，还没实例化对象之前，执行一些初始化操作，$el属性未见 created() &#123; console.log(\"我是created \" + this.msg); &#125;, // mount阶段 // 1.DOM未完成挂载，数据也初始化完成，但是数据的双向绑定还是显示&#123;&#123;&#125;&#125;，这是因为Vue采用了Virtual DOM（虚拟Dom）技术。先占住了一个坑 beforeMount() &#123; console.log(\"我是beforeMount\") &#125;, // 数据和DOM都完成挂载，在上一个周期占位的数据把值给渲染进去。可以在这边请求，不过created请求会更好一些。这个周期适合执行初始化需要操作DOM的方法。 mounted() &#123; console.log(\"我是mounted\") &#125;, // updata阶段 ---当内部的data发生改变时触发 // 1.只要是页面数据改变了都会触发，数据更新之前，页面数据还是原来的数据，当你请求赋值一个数据的时候会执行这个周期，如果没有数据改变不执行。 beforeUpdate() &#123; console.log(\"我是beforeUpdata\") &#125;, // 2.只要是页面数据改变了都会触发，数据更新完毕，页面的数据是更新完成的。beforeUpdate和updated要谨慎使用，因为页面更新数据的时候都会触发，在这里操作数据很影响性能和容易死循环。 updated() &#123; console.log(\"我是updated\") &#125;, // destroy阶段 --- 当内部实例被销毁时触发 // 在实例销毁之前调用。实例仍然完全可用 beforeDestroy() &#123; console.log(\"我是beforeDestroy\") &#125;, // 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用 destroyed() &#123; console.log(\"我是Destroy\") &#125;, &#125;) &lt;/script&gt; 6.组件A：组件的定义：组件是可复用的 Vue 实例，且带有一个名字B：组件名的定义：1.短横线类型(kebab-case) 2.驼峰命名法(PascalCase)C：组件的注册：1.全局注册 2.局部注册 3.模块化中注册组件​ （1）全局注册：在Vue实例之前使用Vue.component 来创建组件，也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (new Vue) 的模板中 123456789101112//使用全局组件&lt;div id=\"app\"&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;component-b&gt;&lt;/component-b&gt; &lt;component-c&gt;&lt;/component-c&gt;&lt;/div&gt;//注册全局组件Vue.component('component-a', &#123; /* ... */ &#125;)Vue.component('component-b', &#123; /* ... */ &#125;)Vue.component('component-c', &#123; /* ... */ &#125;)new Vue(&#123; el: '#app' &#125;) ​ （2）局部注册：在Vue实例外部定义变量，在Vue内部注册组件 12345678var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123; components: &#123; 'component-a': ComponentA &#125;, // ...&#125; ​ （3）在vue-cli脚手架中模块化局部注册组件 1234567891011//局部注册import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default &#123; components: &#123; ComponentA, ComponentC &#125;, // ...&#125; ​ （4）基础组件的自动化全局注册，可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为基础组件 1234567891011import BaseButton from './BaseButton.vue'import BaseIcon from './BaseIcon.vue'import BaseInput from './BaseInput.vue'export default &#123; components: &#123; BaseButton, BaseIcon, BaseInput &#125;&#125; D：组件的通信​ （1）父组件传子组件 ​ 方法：在父组件中动态绑定属性，属性名称和属性值都是传递数据的名称，然后在子组件中通过props接受父组件传递过来的数据，然后在子组件中就能够使用了 ​ （2）子组件向父组件传值 ​ 方法：通过在子组件中定义方法用来触发Vue实例的$emit方法进行传递参数this.$emit(‘传递的方法名称’,传递的值)，然后再在父组件上动态绑定子组件传递过来的事件，然后再方法中接受参数，得到值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//子传父的子组件const myheader = &#123; template:` &lt;div&gt; &lt;p&gt;我是首页部分&lt;/p&gt; &lt;input type=\"text\" @input=\"myhandler\" /&gt; &lt;/div&gt; `, data:function()&#123; return &#123; mytext:\"大家好呀\" &#125;; &#125;, methods:&#123; myhandler()&#123; // console.log(this.mytext); this.$emit('getchilddata',this.mytext) &#125; &#125;&#125;//父传子的子组件const child = &#123; template:` &lt;div&gt; &lt;div&gt;我是栏目页&lt;/div&gt; &#123;&#123;datalist&#125;&#125; &lt;ul&gt; &lt;li v-for=\"data in datalist\"&gt;&#123;&#123;data&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, props:['datalist'],&#125;//父组件const parents = &#123; template:`&lt;div&gt;&lt;myheader @getchilddata=\"getChilddata\"&gt;&lt;/myheader&gt;&lt;child:datalist=\"datalist\"&gt;&lt;/child&gt;&lt;/div&gt;`, components:&#123; myheader, child, &#125;, data:function()&#123; return &#123; datalist:[ '1','2','3' ] &#125; &#125;, methods: &#123; getChilddata(mytext)&#123; console.log(mytext); &#125; &#125;,&#125;Vue.component('parents',parents); ​ （3）如果组件的层级不是父子，那使用上述方法就复杂了，Vue提供了中央事件总线bus传递 ​ 原理：通过创建bus实例，传数据通过bus.$emit(‘方法’,传递的数据) ，取数据通过bus.$on(‘传递过来的方法’,(val)=&gt;{ 传递过来的值 }) 1234567891011121314151617181920212223242526272829303132333435代码： &lt;script&gt; const bus = new Vue() const br1 = &#123; template:` &lt;input type=\"text\" v-model=\"mytext\" @input=\"mybus\"/&gt; `, data:function()&#123; return &#123; mytext:'123', &#125; &#125;, methods: &#123; mybus()&#123; bus.$emit('handdata',this.mytext) &#125; &#125;, &#125; const br2 = &#123; template:` &lt;p&gt;br1传递过来的参数：&#123;&#123;brothmsg&#125;&#125;&lt;/p&gt; `, data:function()&#123; return &#123; brothmsg:'' &#125; &#125;, created()&#123; bus.$on('handdata',(val)=&gt;&#123; this.brothmsg=val &#125;) &#125;, &#125; Vue.component('br1',br1) Vue.component('br2',br2)","categories":[],"tags":[]},{"title":"JavaScript基础","slug":"Javascript基础笔记","date":"2020-06-02T14:09:15.000Z","updated":"2020-06-02T14:09:35.030Z","comments":true,"path":"2020/06/02/Javascript基础笔记/","link":"","permalink":"http://yoursite.com/2020/06/02/Javascript%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Javascript基础笔记一、 Javascript简介1.JavaScript的历史 1994年，网景公司推出第一款真正意义上的浏览器 1995年 , sun 公司推出了Java 1995年 , 网景公司 , sun公司 和网景公司的员工 布兰登 · 艾克 一起开发了 JavaScript 2.JavaScript的概述与作用概述：JavaScript 是一门动态的、弱类型、轻量级的解释型高级编程语言。它基于原型，支持面向对象 和函数式编程等多种编程范式。通常称为 js。 作用：实现页面的交互 ：用户操作的交互 , 数据的交互！ 3.JavaScript的组成部分 一个完整的 JavaScript 实现是由以下3个不同部分组成的：核心（ECMAScript）描述了JavaScript语法和对象、文档对象模型（Document Object Model，简称 DOM）、浏览器对象模型（Browser Object Model，简称 BOM） window 是 JavaScript 中的内置对象，代表整个浏览器窗口，是 BOM 中的一员 ，浏览器对象模型 – 操作 浏览器。 documenet 是 JavaScript 中的内置对象，每个载入浏览器的 HTML 文档都会成为 document 对象，是DOM 中的一员 ，文档对象模型 – 操作HTML,css。 二、JavaScript的语法1.行内式​ 在 标签中 直接定义 JavaScript的 代码内容(这种语法不推荐使用,书写不方便,而且不利于重复使用一般做调试使用) 2.内部式​ 在script标签中,直接定义JavaScript代码 —–&gt; 一般放在 body内部的最下方,也就是所有的html标签的内容的最后,因为牵扯到 代码的执行顺序 3.外部式​ 在 外部 js 文件中 (也就是扩展名是 js的文件),直接定义 JavaScript代码,通过一个 带有 src 属性的 script标签,来导入 4.特殊标签 —&gt; a标签​ 超链接是一个特殊的标签,特殊在如果要执行JavaScript程序，超链接标签,href的属性值,必须定义为 JavaScript:; 才会执行 1例：&lt;a href&#x3D;&quot;JavaScript:;&quot; id&#x3D;&quot;a1&quot;&gt;百度&lt;&#x2F;a&gt; 三、JavaScript 变量1.定义​ 官方定义：存储在内存之中的,带有名称的,数据信息,其中存储的数据,在执行过程中,是可以改变的。 实际上 就是容器 , 存储数据的容器.所有的计算机程序,数据都会存储咋变量中,通过操作变量,来操作数据。 2.规则 —-&gt; 必须遵守 变量名称的内容,只能是数字,字母(大小写都可以),下划线 _ ,美元符号 $ 不能以数字开头 一般是以字母或者下划线开头 严格区分大小写 不要使用保留词和关键词 —-&gt;例如function,push等，程序原有意义的名称 3.建议遵守的规则 不要使用中文 见名知意 – 看见变量名称,就知道存储的是什么数据 驼峰命名法 – 多个单词组成的变量名称,每个单词的首字符大写大驼峰：UserName UserPwd 小驼峰 – 第二个单词开始,首字符大写：userName userPwd 四、JavaScript 数据类型1.布尔类型/布尔值(Boolean / bool )​ 在计算机语言中,布尔值,表示 真(true) / 假(false) 这样的两个数值,往往是 比较 或者 判断的结果. 2.字符串类型(String / str)​ 只要是用单双引号包在一起的都是字符串类型 ​ 引号,双引号的字符串,都不能解析变量，解析变量的方法： 方法1,使用字符串拼接方式 12var airPollution &#x3D; 52 ; console.log( &#39;今天的空气污染是 : airPollution&#39; ); ​ 方法2,使用模板字符串,可以解析变量，模板字符串 使用的 是 反引号 (键盘上方 1 左侧的按钮),使用 ${} 包裹变量 1console.log( &#96;今天的空气污染是 : $&#123;airPollution&#125;&#96; ); 注：字符串的拼接，将两个字符串,拼接为一个字符串,称为字符串的拼接，拼接符用”+“。可以多个字符串拼接，只要拼接的一方是字符串，就执行字符串拼接操作 3.数值类型A.整数(integer / int)​ 包括二进制，八进制，十进制，十六进制 B.小数(浮点数float)​ 有效数值：在JavaScript中,对于浮点数的总位数有规定,一个浮点数,有效数字/有效数值,最多 17 位,所谓的有效数字,值得是,左起,非零的数值 ​ 科学计数法：2e3表示2乘10的3次方，虽然是个整数，但是程序当浮点数处理 ​ 浮点数的误差 ： 浮点数的 精度丢失 / 精度溢出 C.NaN​ 定义：不是一个数值 ​ 运算 ,只要有NaN参与,执行结果都是NaN，如果是加法运算并且有字符串参与 , 则进行字符串拼接操作 ​ 注：NaN 永远 不会等于 NaN NaN == NaN 执行结果是 false，因为JavaScript的规定, NaN表示的是非数字, 但是这个非数字也是不同的 4.undefined和null​ undefined 表示没有数值 — 应该有数值,但是现在没有数值 null 表示数值为空 — 表示有数值,但是数值是”空” 可以直接给变量,赋值 undefined 和 null，但是必须时小写的 五、JavaScript的三种调试方法1, window.alert(‘内容’) — 弹出提示框2, document.write(‘内容’) — 在页面输出3, console.log(‘内容’) — 控制台输出 — 浏览器控制台 console 内容中（常用）六、数据类型的检测1.isNaN（变量） 作用：判断一个数据是不是数字 console.log(isNaN(NaN)) 返回值：true 或 false isNaN（变量）：如果变量是一个数字，返回 false；如果变量不是一个数字，返回 true 2.typeof(变量/数据)方法 作用：查询变量中存储数据的数据类型console.log(typeof(变量)) 返回值：数据类型 typeof 并不能非常准确的表示每一种数据类型，一般是使用判断 布尔类型 数值类型 字符串类型 undefined类型 七、数据类型的转化1.其他数据类型转化为Number数据类型：自动转换：布尔类型 : true —&gt; 1， false —&gt; 0，undefined : 转化为 NaN ，null : 转化为 0 ​ 如果整个字符串,是纯数字字符串,或者符合科学计数法 —&gt; 转化为对应的数值 ​ 如果字符串内有不符合数字规范的内容 —&gt; 转化为 NaN ​ 数组,对象,函数执行结果都是 NaN 强制转换： Number(变量) 转换成 number 数据类型，把数据看成一个整体去转换，那么如果变量中的数据不完全是数字的话，就会得到一个 NaN parseInt(变量) 使用 *pasrInt() *转换，不是将数字看成一个整体，而是从数据的最左边开始识别，当遇到不是数字的字符之后，会停止转换，返回前面的数字 parseFloat(变量) 带小数点的 number 类型，只识别一次小数点 12var age='18.3.35a';console.log(parseFloat(age)); //18.3 隐式转换 操作除了+以外的数学运算 [- * / %] 2.其他数据类型转化为String数据类型：自动转换：执行 字符串拼接 时, 会将其他数据类型转化为字符串类型 ​ 特殊 数组 —&gt; 将 [] 中的内容,转化为字符串的形式,进行拼接 对象 —&gt; 任何对象,任何内容,都会转化为 [object Object] 固定的内容形式 函数 —&gt; 将所有的程序代码,转化为字符串 强制转换： String(变量) 转换成字符串类型 toString() 语法：变量.toString(进制数) 注意：进制范围2~36，.toString前必须写变量，不能写数值 3.其他数据类型转换为Boolean数据类型：自动转换：在 执行 if 判断时 ,其他数据类型会自动转化为布尔类型。 ​ 转换为false的有：’ ‘、NaN、0、undefined、null，其他的都为true. 强制转换： Boolean( 数据/变量 ),转化原则与自动转化原则相同。false : 0 ‘’ undefined null NaN。true : 其他数据,都转化为true 1例：console.log( Boolean(100) ); 八、JavaScript运算符1.算数运算符： 加（+）： + 号两边的数都是 number 类型的数字才会进行加法运算，如果+号两边有一边为 string 数据类型就会进行字符串的拼接。 减（-） 乘（*） 除（/） 除数,也就是第二个数值,不能为 0，若为0执行结果为Infinity(表示无穷大) 求余（取模）（%） 余数可以为负值，余数的正负 与 被除数(第一个数值)的正负相同 2.赋值运算符：都会先把右侧的表达式,计算出一个结果,再与左侧变量进行运算 = ：简单的赋值，把右边的值赋值给左边的变量 一个变量中,只能存储一个数据 += ：把符号左边的变量值+右边的值，然后在赋值给左边的变量 如果是有字符串参与,执行的字符串拼接操作 -= ：把符号左边的变量值-右边的值，然后在赋值给左边的变量 *= ：把符号左边的变量值*右边的值，然后在赋值给左边的变量 /= ：把符号左边的变量值/右边的值，然后在赋值给左边的变量 %= ：把符号左边的变量值%右边的值，然后在赋值给左边的变量 是模进行运算 3.关系（比较）运算符：结果一定是 布尔类型 true / false ＞：大于 ＜：小于 ＞=：大于等于 ＜=：小于等于 ==：等于（只比较两个变量的值，而不管数据类型） !=：不等于 ===：全等（既比较变量，也判断数据类型） !==：全不等 4.自增自减运算符（一元运算符）前置运算符：++i;–i; —-&gt;前置是将自身自加1/自减1并改变自身的存储变量，然后再参与程序的执行 后置运算符：i++;i–; —-&gt;后置是当前位置上 不执行++操作,也就是不改变 变量中存储的原始数值，当前位置上 仍然是原始数值参与该程序的执行，从下一个位置,也就是下一次使用变量时,显示++ 操作的结果 注：当执行自增，自减操作时，都会改变内部的存储变量 12345var a = 0;var b = 0; b = a++ + ++a ; //b=0+2console.log(a); //a为2console.log(b);//b为2 5.逻辑运算符 &amp;&amp;（与）： “&amp;&amp;”逻辑与(并且关系)。如果左右两个两个条件同时满足时，则结果为true，否则，结果为false ||（或）： “||”逻辑或。左右两个条件，只要有一个满足，则返回true，否则，返回false。 ！（非）： “!”取反运算。!true = false !false = true !100 = false 逻辑运算符的短路求值：为了提高程序的执行效果,如果最终的结果已经确定,多余的程序就不会执行 ​ 逻辑与 表达式1 &amp;&amp; 表达式2 两个表达式的结果,都是true,逻辑与的结果才是true 第一个表达式结果是 false 第二个表达式的内容不执行 整个逻辑就是false​ 逻辑或 表达式1 || 表达式2 当 两个表达式都是false , 逻辑或的结果是false 逻辑或 第一个表达式结果是 true 第二个表达式的内容不执行 6.三元运算符(三目)语法：条件 ? 值1 : 值2 条件成立执行值1，否则执行值2 九.JavaScript 流程控制（顺序结构）1.顺序结构： 正常的代码执行顺序（从上到下，从左到右） JavaScript 是一个单线程执行语言 2.选择结构：A.if 分支结构： if 单分支语句语法： 123if(条件)&#123; 当条件成立（true）才执行&#125; if 双分支语句语法： 12345if(条件)&#123; 条件成立时执行的语句&#125;else&#123; 条件不成立时执行的语句&#125; if 多分支语句语法： 123456789if(条件1)&#123; 条件1成立时执行的语句&#125;else if(条件2)&#123; 条件1不满足，条件2成立时执行的语句&#125;else if(条件3)&#123; 条件1和条件2不满足，条件3成立时执行的语句&#125;else&#123; 当所有条件都不执行时执行的语句&#125; B.switch 多值匹配结构： switch 分岔，根据特定的值，选择要执行的代码 语法如下： 1234567891011121314switch (要判断的变量) &#123; case 情况1: 情况1要执行的代码 break; case 情况2: 情况2要执行的代码 break; case 情况3: 情况3要执行的代码 break; default: 上述情况都不满足的时候执行的代码 break;&#125; switch 语法需要注意： switch 中是值匹配，且用全等于（===）来匹配 case 穿透：当匹配到一个 case 值之后，就跳转到当前匹配case值并执行以下所有代码，比if更高效。 switch 使用 break 解决 case 穿透 ，防止全部输出。 3.循环结构：A.while 循环： 语法如下： 12345[1]初始化值while([2]条件)&#123; [3]满足条件时执行的代码 [4]变量更新（不进行变量更新，会导致死循环）&#125; B.do…while 循环： 语法如下： 12345[1初始化值]do&#123; [3]满足条件时执行的代码 [4]变量更新&#125;while( [2]条件 ) 注意：do…while 循环，不管 while 的条件成不成立，那么 do 中的代码都会被执行一次 C.for循环结构：执行顺序很重要 语法如下： 123for( [1]初始化值 ; [2]条件 ; [4]变量更新 )&#123; [3]满足条件时执行的代码&#125; 案列： 1234// 利用for循环打印1-100for( var i=1; i&lt;=100;i++)&#123; document.write(i);&#125; D.for循环嵌套 –&gt;先进入外层循环，执行内层循环（把内层循环执行结束后，然后第二次进入外层循环）123456789//做九九乘法表var int1=''; for(var i =1; i&lt;=9; i++)&#123; for(var j=1; j &lt;= i; j++)&#123; int1 += j + '×' + i + '=' + j * i +'&amp;nbsp;&amp;nbsp;&amp;nbsp;'; &#125; int1 += '&lt;br/&gt;'; &#125; document.write(int1); 十、break 和 continue 的区别1、break： 在循环中使用 break 时，终断循环（跳出循环），终断整个循环 2、continue： 终断本次循环，继续进行下一次循环 十一、JavaScript函数1.函数的定义和特点 定义：实现固定功能的代码块函数是工具,是实现功能的工具 特点：封装: 将需要的代码,写入到函数中**重复**: 一个函数可以反复调用 **调用**: 可以在任意需要位置上调用执行代码 2.函数的创建/封装(所谓封装，将代码放在函数中) 函数声明： 12345678//函数声明式创建函数function f1() &#123; //需要编写的代码&#125;// function: 声明函数的关键字，表示接下来是一个函数了// f1: 函数的名字，我们自己定义的（遵循变量名的命名规则和命名规范）// (): 必须写，是用来放参数的位置（一会我们再聊）// &#123;&#125;: 就是我们用来放一段代码的位置（也就是我们刚才说的 “盒子”） 字面量方式创建（赋值式） 123var f2 = function() &#123; //需要编写的代码&#125; 使用 Function 构造函数创建（不推荐使用） 12var f3 = new Function('参数1','参数2',...,'函数要执行的代码')；//构造函数的参数中最后一个参数为函数体的内容，其余均为函数的形参 3.函数的调用和执行(函数不调用不执行) 函数名(实参);，可以在任何地方调用，但如果定义函数是使用变量定义，就必须在定义函数后调用 4.函数的参数 形参： 在函数声明时写在函数名后面圆括号中的变量 相当于在函数内部定义一个变量 123function aa(a,b,c)&#123; console.log(a,b,c)&#125; 实参： 在函数调用时写在函数名后面圆括号中的数据 实实在在的数据，给形参赋值 1aa(1,2,3) 参数个数的关系： 形参个数 = 实参个数：实参从左到右一一给形参赋值 形参个数 &gt; 实参个数：实参从左到右一一给形参赋值，但多余的形参没有值时，就会得到 undefined 形参个数 &lt; 实参个数：实参从左到右一一给形参赋值，函数内部拿不到多余的实参 5.函数的返回值 函数体中 return 语句给函数一个返回值 或者 终止函数的执行。 当 return 语句被执行时，函数立即返回而不在执行 剩余的代码 return语句后面 跟上你要返回的数据（可以是一个表达式，可以式任意的数据类型） 注：函数总是有一个返回值，如果函数体中没有 return 语句或者 return 后面为空，那么函数将总式返回一个 undefined 6.计算机的内存(栈和堆) 栈： 存储类型：基本数据类型 : 布尔 数值 字符串 undefined null 存储原理：将定义的简单数据类型存储在栈中 堆： 存储类型：复杂数据类型 : 对象 数组 函数 存储原理：将定义的变量名存储在栈中，并给一个存储地址：例：0x123123;然后再帮复杂数据存在堆中，每次访问时先访问栈，然后根据地址访问堆中的数据 7.函数的预解析（提前解析） 预解析：浏览器会在代码执行之前，先去解析通读代码中的一些变量 预解析会解析： var 声明的变量 函数 var 声明的变量怎么解析： 告诉计算机程序,这个变量已经存在,只是当前没有赋值，如果在赋值之前使用变量时，就会得到一个 undefined 声明式函数会怎么解析： 如果是声明式函数的创建，那么就会把这段声明式函数创建代码提前告诉浏览器有一个 fun() 函数变量，并且给这个变量赋值一个函数的地址 赋值式创建函数怎么解析： 会告诉浏览器 fn 变量可用，但是并没有赋值，在函数中赋值给 fn 之前，fn 是一个 undefined 的变量，那么使用 fn() 调用时，会报错：fn is not a function 1234fn()var fn = function()&#123; conlose.log(1)&#125; 8.全局变量和局部变量 全局变量 定义在函数之外的变量,称为全局作用域变量/全局变量 声明在全局的，可以在任何地方使用 如果在函数局部声明变量没有用 var，那么这个变量是全局的，会覆盖之前声明的 局部变量 在局部使用 var 声明的变量，只能在局部使用 包括函数的参数,定义在函数内部的变量,都称为局部作用域变量 / 局部变量， 只能在函数内部使用,如果外部想要直接调用,是不行的 作用域链： 函数去访问变量的时候，会从就近的位置开始去寻找这个变量，直到找到这个变量位置的时候，这个过程叫做作用域链 9.递归函数 定义：一种特殊的函数,就是在函数内部,调用函数自己本身 1.调用递归函数,一定要有条件,无条件的调用递归函数,会一直执行调用,不会停止 2,调用递归函数,进入递归函数,会由外至内执行,结束递归函数,会从内至外执行 例：function fun(num){ num--; if(num &gt;=1){ fun(num); } // 将执行的输出,写在递归调用之下 console.log(num); } fun(5);----&gt;将输出0,1,2,3,4 &lt;!--￼21--&gt; 3、数组的创建方式： 1.字面量方式创建 1var 变量 = [ 数据1 , 数据2 , 数据3 , ..... ]; 2.构造函数方式 – 创造一个空数组 1var arr2 = new Array();，然后通过索引的方法想数组中添加数据 4.数组的索引下标 1.索引下标调用数据，从0开始，例：arr[0]; 第一个值 ——–二维数组的调用arr[0][0] 2.通过索引下标,来修改数组中,存储的单元的数据，对已存在的索引下标,进行赋值,进行的是重复赋值,会覆盖之前存储的数据 3.通过索引下标,来新增数组的单元，最好是连续的下标，不然中间为赋值的会是empty 4,通过索引下标,来删除数组的单元,定义数组的length长度属性,通过定义数组的单元个数,来删除数组的单元,从结尾处删除 5.数组的arr.length length表示数组的长度,也就是单元的个数,最大的索引下标 是 length-1 ,我们一般在便利数组时用到 6.排序算法 冒泡排序 原理: 相邻的两个单位,比较存储的数据， 如果第一个单元的数据较大,就将两个相邻单元,交换存储数据 过程: 从起始单元开始比较,第一次循环,会选择出一个最大值,放在数组所有单元的最后， 之后,每次循环,都会比较出一个本次循环的最大值,放在当前参与比较单元的最后，之前已经比较选出的单元,不会参与下一次比较 优化： 1, 单次循环,最后一个单元,通过倒数第二个单元,参与比较， 最后一个单元,就不参与单次循环 2, 之前比较出的最大值,不再参与下一次的比较 3, n个单元,只要循环比较n-1次,最后就一个单元时,不要再循环比较 代码 ​ 1234567891011var arr=[5,2,4,6,3]; for(var i=0;i&lt;=arr.length-1;i++)&#123; for(var j=0;j&lt;=arr.length-i-1;j++)&#123; if(arr[j] &gt;= arr[j+1])&#123; var map = arr[j]; arr[j]=arr[j+1]; arr[j+1]=map; &#125; &#125; &#125;console.log(arr); 选择排序 原理：先定义循环的起始位置默认为最小值所在位置 过程：从起始位置下一个位置开始,执行循环，如果有位置上的数值,小于,存储索引位置上的数值，就存储这个位置的索引值，循环结束,比较存储的索引,是否是起始位置索引，如果不是,就交换两个位置上的数值，会将本次循环的最小值,放置在循环的起始位置上，再执行多次循环,完成排序 核心 : 找到最小值的索引,与起始位置交换数值，先找索引 在交换数值 优化 : 1,之前比较的数值不参与一次标记 2,n个单元,只要比较n-1次 ​ 1234567891011121314151617181920212223242526272829代码：var arr =[3,1,4,11,9]; for(var i=0;i&lt;=arr.length-1-1;i++)&#123; var min=i; for(var j=i+1;j&lt;=arr.length-1;j++)&#123; if(arr[min] &gt; arr[j])&#123; min = j; &#125; &#125; if(min != i)&#123; var map = arr[i]; arr[i]=arr[min]; arr[min]=map; &#125; &#125; console.log(arr); 7.数组的方法【1】、push 方法： push 是用来在数组的末尾添加一个元素的： 12345var arr = [1, 2, 3]// 使用 push 方法追加一个元素在末尾arr.push(4)console.log(arr) // [1, 2, 3, 4] push 方法会直接改变原数组 push 方法的返回值：添加之后数组的长度 【2】、pop 方法： pop 是用来删除数组末尾的一个元素的： 12345var arr = [1, 2, 3]// 使用 pop 方法删除末尾的一个元素arr.pop()console.log(arr) // [1, 2] pop 方法会直接改变原数组 pop 方法的返回值：删除掉的那个元素 【3】、unshift 方法： unshift 是在数组的最前面添加一个元素： 12345var arr = [1, 2, 3]// 使用 unshift 方法想数组的最前面添加一个元素arr.unshift(4)console.log(arr) // [4, 1, 2, 3] unshift 方法会直接改变原数组 unshift 方法的返回值：添加之后的数组长度 【4】、shift 方法： shift 方法是删除数组最前面的一个元素： 12345var arr = [1, 2, 3]// 使用 shift 方法删除数组最前面的一个元素arr.shift()console.log(arr) // [2, 3] shift 方法会直接改变原数组 shift 方法的返回值：删除掉的那个元素 【5】、splice 方法： splice 是截取数组中的某些内容，按照数组的索引来截取 语法：arr.splice(idx,num,value) splice总共有 3 个参数，但是第三个参数可以不写 idx ：从哪个索引位置开始 num ：截取多少个 value：替换的新元素 12345var arr = [1, 2, 3, 4, 5]// 使用 splice 方法截取数组arr.splice(1, 2, '我是新内容')console.log(arr) // [1, '我是新内容', 4, 5] splice 方法会直接改变原数组 splice 方法的返回值：以数组形式返回被截取的元素 【6】、reverse 方法： reverse 是用来反转数组的： 12345var arr = [1, 2, 3]// 使用 reverse 方法来反转数组arr.reverse()console.log(arr) // [3, 2, 1] reverse 方法会直接改变原数组 reverse 方法的返回值：返回反转后的数组 【7】、sort 方法： sort 方法是用来给数组排序的： 1234567891011121314var arr = [2, 3, 1]// 使用 sort 方法给数组排序arr.sort()console.log(arr) // [1, 2, 3]var arr = [12, 33, 22, 21, 13, 1, 3, 4, 2, 5, 44];var res = arr.sort(function (a, b) &#123; return b - a // 从大到小排序&#125;); var res = arr.sort(function (a, b) &#123; return a - b; // 从小到大排序&#125;);var res1 = arr.sort(); sort 方法会直接改变原数组 sort 方法的返回值：排序之后的数组 【8】、concat 方法： concat 方法是把多个数组进行拼接： 123456var arr = [1, 2, 3]// 使用 concat 方法拼接数组var newArr = arr.concat([4, 5, 6])console.log(arr) // [1, 2, 3]console.log(newArr) // [1, 2, 3, 4, 5, 6] concat 方法不会改变原数组，而是返回一个新的数组 concat 方法的返回值：返回一个拼接好之后的新数组 【9】、join 方法： join 方法是把数组转化为字符串： 可以自己定义每一项之间链接的内容 join（要用什么内容链接） 12345var arr = [1,2,3,4]var res = arr.join('-')console.log(arr) // [1,2,3,4]console.log(res) // 1-2-3-4 join 方法不会改变原数组 join 方法的返回值：返回链接好的字符串 【10】、indexOf 方法： indexOf 方法判断这个元素是否存在数组当中 12345var arr = [1,2,3,4]var res = arr.indexOf(2)console.log(arr) // [1,2,3,4]console.log(res) // 1 indexOf 方法不会改变原数组 indexOf 方法的返回值：如果数组中有这个元素，就返回这个元素的索引，没有就返回-1 8.数组的深浅拷贝【1】、浅拷贝 定义：直接将一个引用数据类型的地址,赋值给另一个变量存储的，两个变量存储的是相同的内存地址,一个操作,另一个也会改变 1234567891011例：var arr1 &#x3D; [1,2,3,4,5]; &#x2F;&#x2F; 将arr1 存储的内存地址,赋值给arr2,两个变量存储的是相同的内存地址 var arr2 &#x3D; arr1; &#x2F;&#x2F; arr1操作,数组,arr2也会改变 &#x2F;&#x2F; 因为arr1和arr2,同时存储的是相同的数据,操作的也是同一个数组 &#x2F;&#x2F; 同理,arr2,操作数组,arr1也会改变 arr1[0] &#x3D; &#39;北京&#39;; console.log(arr2); 【2】、深拷贝 定义：只复制 引用数据类型中的数值，而不是 复制地址 123456789101112131415161718例：// 只复制arr3中的数据 var arr3 = ['北京','上海','广州','重庆','天津']; // 循环遍历,获取arr3中的所有数据数值,赋值到新的数组中 var arr4 = []; // 通过循环,生成arr3的所有索引下标 for(var i = 0 ; i &lt;= arr3.length-1 ; i++)&#123; // arr3[i] 就是获取 arr3中的 存储的 数据信息 // arr4.push() 将arr3中的数据 arr3[i] , 写入到 arr4中 arr4.push(arr3[i]); &#125; console.log(arr4); arr3[0] = '武汉'; console.log(arr3 , arr4); 9.数组的循环遍历方法1: 通过for循环,生成所有的索引下标—优点是,可以控制循环的起始和结束1例：for(var i &#x3D; 0 ; i &lt;&#x3D; arr.length-1 ; i++)&#123; 程序内容 &#125; 方法2: 通过JavaScript程序,给我们提供的方法来实现循环遍历数组.forEach(function(形参1,形参2,形参3){}) 形参1: 存储的是当前循环次数时,获取的单元数据 参数2: 存储的是当前循环次数时,获取的单元索引下标 参数3: 存储的是原始数组 注意：1.三个形参,不一定都要定义,可以根据实际需求2.形参可以任意定义,只要符合命名规范就可以 3.forEach() 只能循环遍历数组,不能循环遍历对象 12345678910111213141516例：var arr &#x3D; [&#39;北京&#39;,&#39;上海&#39;,&#39;广州&#39;,&#39;重庆&#39;,&#39;天津&#39;]; &#x2F;* 第一次循环,循环对象是 第一个单元 val : 存储数据 &#39;北京&#39; key : 存储索引 0 arr : 存储原始数组 第二次循环,循环对象是 第二个单元 val : 存储数据 &#39;上海&#39; key : 存储索引 1 arr : 存储原始数组 第三次循环,循环对象是 第三个单元 val : 存储数据 &#39;广州&#39; key : 存储索引 2 arr : 存储原始数组 第四次循环,循环对象是 第四个单元 val : 存储数据 &#39;重庆&#39; key : 存储索引 3 arr : 存储原始数组 第五次循环,循环对象是 第五个单元 val : 存储数据 &#39;天津&#39; key : 存储索引 4 arr : 存储原始数组 *&#x2F; &#x2F;&#x2F; arr.forEach(function(val,key,arr)&#123; &#x2F;&#x2F; console.log(val,key,arr); &#x2F;&#x2F; &#125;) 方法3：for(var 自定义变量 in 数组){程序}，自定义变量遍历出来会是存储的索引—-一般用于对象遍历例：var arr = [&apos;北京&apos;,&apos;上海&apos;,&apos;广州&apos;,&apos;重庆&apos;,&apos;天津&apos;]; for(var key in arr){ // 自定义变量,存储索引 0 1 2 3 4 .... console.log(key,arr[key]); // arr[key] 就是索引对应的数据 } 一般是针对对象的循环十三、字符串的方法【1】、split方法： 变量.split(‘分隔符’)—-&gt;将字符串转换为数组，转换为的数组内部不能为函数，对象，不会对原理数据有变化，内部的分隔符是以分隔符为间隔符号,将字符串切割为数组，会将分隔符去掉用逗号隔开 【2】、indexOf()方法 变量.indexOf() — 字符首次出现的位置—-&gt;返回值为字符所在的索引值 如果没有改字符，返回-1，该方法采用的全等判断是否有 【3】、lastindexOf()方法 变量.lastIndexOf() — 字符最后一次出现的位置—-&gt;返回值为字符所在的索引值 【4】、字符大写小写方法 所有字符大写：字符串.toUpperCase(), 所有字符小写：字符串.toLowerCase() 做字符串判断时,有时需要先统一大小写 【5】、charAt()方法,charCodeAt()方法 字符串.charAt()—-获取指定位置的字符—&gt;返回对应值的索引值 字符串.charCodeAt()—-获取指定位置的字符的编码数值—-返回字符在ASCII码表中的数值 【6】、substring()方法 字符串.substring()—字符串的截取 参数1: 截取起始字符的索引下标 参数2: 截取结束字符的索引下标 注：截取的包含首个字符，不包含第二个参数位置的字符 【7】、substr()方法 字符串.substr()—字符串的截取 参数1: 指定截取的起始位置 参数2: 指定截取的字符长度 注意：会截取首个字符 【7】、replace()方法 字符串.replace()—-字符串内容替换函数 第一个参数:字符串原有的,要替换没的 第二个参数:字符串没有的,要新替换进来的","categories":[{"name":"web前端","slug":"web前端","permalink":"http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"我的Javascript规范","slug":"我的javascript规范","date":"2020-06-02T14:08:15.000Z","updated":"2020-06-06T08:35:23.434Z","comments":true,"path":"2020/06/02/我的javascript规范/","link":"","permalink":"http://yoursite.com/2020/06/02/%E6%88%91%E7%9A%84javascript%E8%A7%84%E8%8C%83/","excerpt":"","text":"me JavaScript规范1.代码规范1.1 结构1.1.12.2.1 缩进2.2.1 缩进[强制] 使用 4 个空格做为一个缩进层级，不允许使用 2 个空格 或 tab 字符。[强制] switch 下的 case 和 default 必须增加一个缩进层级。示例： 12345678910111213141516171819202122232425262728293031// goodswitch (variable) &#123; case '1': // do... break; case '2': // do... break; default: // do...&#125;// badswitch (variable) &#123;case '1': // do... break;case '2': // do... break;default: // do...&#125; 2.2.2 空格[强制] 二元运算符两侧必须有一个空格，一元运算符与操作对象之间不允许有空格。示例： 123var a = !arr.length;a++;a = b + c; [强制] 函数声明、具名函数表达式、函数调用中，函数名和 ( 之间不允许有空格。示例： 1234567891011121314151617// goodfunction funcName() &#123;&#125;var funcName = function funcName() &#123;&#125;;funcName();// badfunction funcName () &#123;&#125;var funcName = function funcName () &#123;&#125;;funcName (); [强制] , 和 ; 前不允许有空格。如果不位于行尾，, 和 ; 后必须跟一个空格。示例： 12345// goodcallFunc(a, b);// badcallFunc(a , b) ; [强制] 在函数调用、函数声明、括号表达式、属性访问、if / for / while / switch / catch 等语句中，() 和 [] 内紧贴括号部分不允许有空格。示例： 12345678910111213141516171819202122232425262728// goodcallFunc(param1, param2, param3);save(this.list[this.indexes[i]]);needIncream &amp;&amp; (variable += increament);if (num &gt; list.length) &#123;&#125;while (len--) &#123;&#125;// badcallFunc( param1, param2, param3 );save( this.list[ this.indexes[ i ] ] );needIncreament &amp;&amp; ( variable += increament );if ( num &gt; list.length ) &#123;&#125;while ( len-- ) &#123;&#125; [强制] 单行声明的数组与对象，如果包含元素，{} 和 [] 内紧贴括号部分不允许包含空格。解释： 声明包含元素的数组与对象，只有当内部元素的形式较为简单时，才允许写在一行。元素复杂的情况，还是应该换行书写。 示例： 1234567891011121314151617// goodvar arr1 = [];var arr2 = [1, 2, 3];var obj1 = &#123;&#125;;var obj2 = &#123;name: 'obj'&#125;;var obj3 = &#123; name: 'obj', age: 20, sex: 1&#125;;// badvar arr1 = [ ];var arr2 = [ 1, 2, 3 ];var obj1 = &#123; &#125;;var obj2 = &#123; name: 'obj' &#125;;var obj3 = &#123;name: 'obj', age: 20, sex: 1&#125;; [强制] 行尾不得有多余的空格。2.2.3 换行[强制] 在函数声明、函数表达式、函数调用、对象创建、数组创建、for 语句等场景中，不允许在 , 或 ; 前换行。示例： 1234567891011121314151617181920212223242526// goodvar obj = &#123; a: 1, b: 2, c: 3&#125;;foo( aVeryVeryLongArgument, anotherVeryLongArgument, callback);// badvar obj = &#123; a: 1 , b: 2 , c: 3&#125;;foo( aVeryVeryLongArgument , anotherVeryLongArgument , callback); [建议] 不同行为或逻辑的语句集，使用空行隔开，更易阅读。示例： 12345678// 仅为按逻辑换行的示例，不代表setStyle的最优实现function setStyle(element , property , value) &#123; if (element == null) &#123; return; &#125; element.style[property] = value;&#125; 2.2.4 语句[强制] 不得省略语句结束的分号。[强制] 在 if / else / for / do / while 语句中，即使只有一行，也不得省略块 {...}。示例： 123456789// goodif (condition) &#123; callFunc();&#125;// badif (condition) callFunc();if (condition) callFunc(); [强制] 函数定义结束不允许添加分号。示例： 1234567891011// goodfunction funcName() &#123;&#125;// badfunction funcName() &#123;&#125;;// 如果是函数表达式，分号是不允许省略的。var funcName = function () &#123;&#125;; 2.3 命名[强制] 变量 使用 Camel命名法。示例： 1var loadingModules = &#123;&#125;; [强制] 函数 使用 Camel命名法。示例： 12function stringFormat(source) &#123;&#125; [强制] 函数的 参数 使用 Camel命名法。示例： 12function hear(theBells) &#123;&#125; [强制] 类 使用 Pascal命名法。示例： 12function TextNode(options) &#123;&#125; [强制] 类的 方法 / 属性 使用 Camel命名法。示例： 12345678function TextNode(value, engine) &#123; this.value = value; this.engine = engine;&#125;TextNode.prototype.clone = function () &#123; return this;&#125;; [强制] 枚举变量 使用 Pascal命名法，枚举的属性 使用 全部字母大写，单词间下划线分隔 的命名方式。示例： 123456var TargetState = &#123; READING: 1, READED: 2, APPLIED: 3, READY: 4&#125;; [强制] 命名空间 使用 Camel命名法。示例： 1equipments.heavyWeapons = &#123;&#125;; [强制] 由多个单词组成的缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。示例： 1234567function XMLParser() &#123;&#125;function insertHTML(element, html) &#123;&#125;var httpRequest = new HTTPRequest(); [强制] 类名 使用 名词。示例： 12function Engine(options) &#123;&#125; [建议] 函数名 使用 动宾短语。示例： 12function getStyle(element) &#123;&#125; [建议] boolean 类型的变量使用 is 或 has 开头。示例： 12var isReady = false;var hasMoreCommands = false; [建议] Promise对象 用 动宾短语的进行时 表达。示例： 12var loadingData = ajax.get('url');loadingData.then(callback); 2.4 注释2.4.1 单行注释[强制] 与需要注释的文本在同一行。2.4.2 多行注释[建议] 避免使用 /*...*/ 这样的多行注释。有多行注释内容时，使用多个单行注释。2.4.3 文档化注释[强制] 为了便于代码阅读和自文档化，以下内容必须包含以 /**...*/ 形式的块注释中。解释： 文件 namespace 类 函数或方法 类属性 事件 全局变量 常量 AMD 模块 [强制] 文档注释前必须空一行。[建议] 自文档化的文档说明 what，而不是 how。2.4.4 类型定义[强制] 类型定义都是以 { 开始, 以 } 结束。解释： 常用类型如：{string}, {number}, {boolean}, {Object}, {Function}, {RegExp}, {Array}, {Date}。 类型不仅局限于内置的类型，也可以是自定义的类型。比如定义了一个类 Developer，就可以使用它来定义一个参数和返回值的类型。 [强制] 对于基本类型 {string}, {number}, {boolean}，首字母必须小写。 类型定义 语法示例 解释 String {string} – Number {number} – Boolean {boolean} – Object {Object} – Function {Function} – RegExp {RegExp} – Array {Array} – Date {Date} – 单一类型集合 {Array.&lt;string&gt;} string 类型的数组 多类型 {(number｜boolean)} 可能是 number 类型, 也可能是 boolean 类型 允许为null {?number} 可能是 number, 也可能是 null 不允许为null {!Object} Object 类型, 但不是 null Function类型 {function(number, boolean)} 函数, 形参类型 Function带返回值 {function(number, boolean):string} 函数, 形参, 返回值类型 Promise Promise.&lt;resolveType, rejectType&gt; Promise，成功返回的数据类型，失败返回的错误类型 参数可选 @param {string=} name 可选参数, =为类型后缀 可变参数 @param {…number} args 变长参数, …为类型前缀 任意类型 {*} 任意类型 可选任意类型 @param {*=} name 可选参数，类型不限 可变任意类型 @param {…*} args 变长参数，类型不限 2.4.13 细节注释对于内部实现、不容易理解的逻辑说明、摘要信息等，我们可能需要编写细节注释。 [建议] 细节注释遵循单行注释的格式。说明必须换行时，每行是一个单行注释的起始。示例： 1234567function foo(p1, p2, opt_p3) &#123; // 这里对具体内部逻辑进行说明 // 说明太长需要换行 for (...) &#123; .... &#125;&#125; [强制] 有时我们会使用一些特殊标记进行说明。特殊标记必须使用单行注释的形式。下面列举了一些常用标记：解释： TODO: 有功能待实现。此时需要对将要实现的功能进行简单说明。 FIXME: 该处代码运行没问题，但可能由于时间赶或者其他原因，需要修正。此时需要对如何修正进行简单说明。 HACK: 为修正某些问题而写的不太好或者使用了某些诡异手段的代码。此时需要对思路或诡异手段进行描述。 XXX: 该处存在陷阱。此时需要对陷阱进行描述。 3 语言特性3.1 变量[强制] 变量、函数在使用前必须先定义。解释： 不通过 var 定义变量将导致变量污染全局环境。 示例： 12345// goodvar name = 'MyName';// badname = 'MyName'; 原则上不建议使用全局变量，对于已有的全局变量或第三方框架引入的全局变量，需要根据检查工具的语法标识。 示例： 12/* globals jQuery */var element = jQuery('#element-id'); [强制] 每个 var 只能声明一个变量。解释： 一个 var 声明多个变量，容易导致较长的行长度，并且在修改时容易造成逗号和分号的混淆。 示例： 123456789// goodvar hangModules = [];var missModules = [];var visited = &#123;&#125;;// badvar hangModules = [], missModules = [], visited = &#123;&#125;; [强制] 变量必须 即用即声明，不得在函数或其它形式的代码块起始位置统一声明所有变量。解释： 变量声明与使用的距离越远，出现的跨度越大，代码的阅读与维护成本越高。虽然JavaScript的变量是函数作用域，还是应该根据编程中的意图，缩小变量出现的距离空间。 示例： 12345678910111213141516171819202122232425262728293031323334353637// goodfunction kv2List(source) &#123; var list = []; for (var key in source) &#123; if (source.hasOwnProperty(key)) &#123; var item = &#123; k: key, v: source[key] &#125;; list.push(item); &#125; &#125; return list;&#125;// badfunction kv2List(source) &#123; var list = []; var key; var item; for (key in source) &#123; if (source.hasOwnProperty(key)) &#123; item = &#123; k: key, v: source[key] &#125;; list.push(item); &#125; &#125; return list;&#125; 3.2 条件[强制] 在 Equality Expression 中使用类型严格的 ===。仅当判断 null 或 undefined 时，允许使用 == null。解释： 使用 === 可以避免等于判断中隐式的类型转换。 示例： 123456789// goodif (age === 30) &#123; // ......&#125;// badif (age == 30) &#123; // ......&#125; [建议] 尽可能使用简洁的表达式。示例： 1234567891011// 字符串为空// goodif (!name) &#123; // ......&#125;// badif (name === '') &#123; // ......&#125; 1234567891011// 字符串非空// goodif (name) &#123; // ......&#125;// badif (name !== '') &#123; // ......&#125; 1234567891011// 数组非空// goodif (collection.length) &#123; // ......&#125;// badif (collection.length &gt; 0) &#123; // ......&#125; 1234567891011// 布尔不成立// goodif (!notTrue) &#123; // ......&#125;// badif (notTrue === false) &#123; // ......&#125; 1234567891011// null 或 undefined// goodif (noValue == null) &#123; // ......&#125;// badif (noValue === null || typeof noValue === 'undefined') &#123; // ......&#125; [建议] 按执行频率排列分支的顺序。解释： 按执行频率排列分支的顺序好处是： 阅读的人容易找到最常见的情况，增加可读性。 提高执行效率。 [建议] 对于相同变量或表达式的多值条件，用 switch 代替 if。示例： 1234567891011121314151617181920// goodswitch (typeof variable) &#123; case 'object': // ...... break; case 'number': case 'boolean': case 'string': // ...... break;&#125;// badvar type = typeof variable;if (type === 'object') &#123; // ......&#125;else if (type === 'number' || type === 'boolean' || type === 'string') &#123; // ......&#125; [建议] 如果函数或全局中的 else 块后没有任何语句，可以删除 else。示例： 123456789101112131415161718// goodfunction getName() &#123; if (name) &#123; return name; &#125; return 'unnamed';&#125;// badfunction getName() &#123; if (name) &#123; return name; &#125; else &#123; return 'unnamed'; &#125;&#125; 3.3 循环[建议] 不要在循环体中包含函数表达式，事先将函数提取到循环体外。解释： 循环体中的函数表达式，运行过程中会生成循环次数个函数对象。 示例： 12345678910111213141516// goodfunction clicker() &#123; // ......&#125;for (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; addListener(element, 'click', clicker);&#125;// badfor (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; addListener(element, 'click', function () &#123;&#125;);&#125; [建议] 对循环内多次使用的不变值，在循环外用变量缓存。示例： 123456789101112131415// goodvar width = wrap.offsetWidth + 'px';for (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; element.style.width = width; // ......&#125;// badfor (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; element.style.width = wrap.offsetWidth + 'px'; // ......&#125; [建议] 对有序集合进行遍历时，缓存 length。解释： 虽然现代浏览器都对数组长度进行了缓存，但对于一些宿主对象和老旧浏览器的数组对象，在每次 length 访问时会动态计算元素个数，此时缓存 length 能有效提高程序性能。 示例： 1234for (var i = 0, len = elements.length; i &lt; len; i++) &#123; var element = elements[i]; // ......&#125; [建议] 对有序集合进行顺序无关的遍历时，使用逆序遍历。解释： 逆序遍历可以节省变量，代码比较优化。 示例： 12345var len = elements.length;while (len--) &#123; var element = elements[len]; // ......&#125; 3.4 类型3.4.1 类型检测[建议] 类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。示例： 1234567891011121314151617181920212223242526272829// stringtypeof variable === 'string'// numbertypeof variable === 'number'// booleantypeof variable === 'boolean'// Functiontypeof variable === 'function'// Objecttypeof variable === 'object'// RegExpvariable instanceof RegExp// Arrayvariable instanceof Array// nullvariable === null// null or undefinedvariable == null// undefinedtypeof variable === 'undefined' 3.4.2 类型转换[建议] 转换成 string 时，使用 + &#39;&#39;。示例： 1234567// goodnum + '';// badnew String(num);num.toString();String(num); [建议] 转换成 number 时，通常使用 +。示例： 12345// good+str;// badNumber(str); [建议] string 转换成 number，要转换的字符串结尾包含非数字并期望忽略时，使用 parseInt。示例： 12var width = '200px';parseInt(width, 10); [强制] 使用 parseInt 时，必须指定进制。示例： 12345// goodparseInt(str, 10);// badparseInt(str); [建议] 转换成 boolean 时，使用 !!。示例： 12var num = 3.14;!!num; [建议] number 去除小数点，使用 Math.floor / Math.round / Math.ceil，不使用 parseInt。示例： 1234567// goodvar num = 3.14;Math.ceil(num);// badvar num = 3.14;parseInt(num, 10); 3.5 字符串[强制] 字符串开头和结束使用单引号 &#39;。解释： 输入单引号不需要按住 shift，方便输入。 实际使用中，字符串经常用来拼接 HTML。为方便 HTML 中包含双引号而不需要转义写法。 示例： 12var str = '我是一个字符串';var html = '&lt;div class=\"cls\"&gt;拼接HTML可以省去双引号转义&lt;/div&gt;'; [建议] 使用 数组 或 + 拼接字符串。解释： 使用 + 拼接字符串，如果拼接的全部是 StringLiteral，压缩工具可以对其进行自动合并的优化。所以，静态字符串建议使用 + 拼接。 在现代浏览器下，使用 + 拼接字符串，性能较数组的方式要高。 如需要兼顾老旧浏览器，应尽量使用数组拼接字符串。 示例： 123456789101112131415// 使用数组拼接字符串var str = [ // 推荐换行开始并缩进开始第一个字符串, 对齐代码, 方便阅读. '&lt;ul&gt;', '&lt;li&gt;第一项&lt;/li&gt;', '&lt;li&gt;第二项&lt;/li&gt;', '&lt;/ul&gt;'].join('');// 使用 `+` 拼接字符串var str2 = '' // 建议第一个为空字符串, 第二个换行开始并缩进开始, 对齐代码, 方便阅读 + '&lt;ul&gt;', + '&lt;li&gt;第一项&lt;/li&gt;', + '&lt;li&gt;第二项&lt;/li&gt;', + '&lt;/ul&gt;'; [建议] 使用字符串拼接的方式生成HTML，需要根据语境进行合理的转义。解释： 在 JavaScript 中拼接，并且最终将输出到页面中的字符串，需要进行合理转义，以防止安全漏洞。下面的示例代码为场景说明，不能直接运行。 示例： 1234567891011// HTML 转义var str = '&lt;p&gt;' + htmlEncode(content) + '&lt;/p&gt;';// HTML 转义var str = '&lt;input type=\"text\" value=\"' + htmlEncode(value) + '\"&gt;';// URL 转义var str = '&lt;a href=\"/?key=' + htmlEncode(urlEncode(value)) + '\"&gt;link&lt;/a&gt;';// JavaScript字符串 转义 + HTML 转义var str = '&lt;button onclick=\"check(\\'' + htmlEncode(strLiteral(name)) + '\\')\"&gt;提交&lt;/button&gt;'; [建议] 复杂的数据到视图字符串的转换过程，选用一种模板引擎。解释： 使用模板引擎有如下好处： 在开发过程中专注于数据，将视图生成的过程由另外一个层级维护，使程序逻辑结构更清晰。 优秀的模板引擎，通过模板编译技术和高质量的编译产物，能获得比手工拼接字符串更高的性能。 模板引擎能方便的对动态数据进行相应的转义，部分模板引擎默认进行HTML转义，安全性更好。 artTemplate: 体积较小，在所有环境下性能高，语法灵活。 dot.js: 体积小，在现代浏览器下性能高，语法灵活。 etpl: 体积较小，在所有环境下性能高，模板复用性高，语法灵活。 handlebars: 体积大，在所有环境下性能高，扩展性高。 hogon: 体积小，在现代浏览器下性能高。 nunjucks: 体积较大，性能一般，模板复用性高。 3.6 对象[强制] 使用对象字面量 {} 创建新 Object。示例： 12345// goodvar obj = &#123;&#125;;// badvar obj = new Object(); [建议] 对象创建时，如果一个对象的所有 属性 均可以不添加引号，建议所有 属性 不添加引号。示例： 1234var info = &#123; name: 'someone', age: 28&#125;; [建议] 对象创建时，如果任何一个 属性 需要添加引号，则所有 属性 建议添加 &#39;。解释： 如果属性不符合 Identifier 和 NumberLiteral 的形式，就需要以 StringLiteral 的形式提供。 示例： 12345678910111213// goodvar info = &#123; 'name': 'someone', 'age': 28, 'more-info': '...'&#125;;// badvar info = &#123; name: 'someone', age: 28, 'more-info': '...'&#125;; [强制] 不允许修改和扩展任何原生对象和宿主对象的原型。示例： 123// 以下行为绝对禁止String.prototype.trim = function () &#123;&#125;; [建议] 属性访问时，尽量使用 .。解释： 属性名符合 Identifier 的要求，就可以通过 . 来访问，否则就只能通过 [expr] 方式访问。 通常在 JavaScript 中声明的对象，属性命名是使用 Camel 命名法，用 . 来访问更清晰简洁。部分特殊的属性（比如来自后端的 JSON ），可能采用不寻常的命名方式，可以通过 [expr] 方式访问。 示例： 12info.age;info['more-info']; [建议] for in 遍历对象时, 使用 hasOwnProperty 过滤掉原型中的属性。示例： 123456var newInfo = &#123;&#125;;for (var key in info) &#123; if (info.hasOwnProperty(key)) &#123; newInfo[key] = info[key]; &#125;&#125; 3.7 数组[强制] 使用数组字面量 [] 创建新数组，除非想要创建的是指定长度的数组。示例： 12345// goodvar arr = [];// badvar arr = new Array(); [强制] 遍历数组不使用 for in。解释： 数组对象可能存在数字以外的属性, 这种情况下 for in 不会得到正确结果。 示例： 1234567891011121314var arr = ['a', 'b', 'c'];// 这里仅作演示, 实际中应使用 Object 类型arr.other = 'other things';// 正确的遍历方式for (var i = 0, len = arr.length; i &lt; len; i++) &#123; console.log(i);&#125;// 错误的遍历方式for (var i in arr) &#123; console.log(i);&#125; [建议] 不因为性能的原因自己实现数组排序功能，尽量使用数组的 sort 方法。解释： 自己实现的常规排序算法，在性能上并不优于数组默认的 sort 方法。以下两种场景可以自己实现排序： 需要稳定的排序算法，达到严格一致的排序结果。 数据特点鲜明，适合使用桶排。 [建议] 清空数组使用 .length = 0。3.8 函数3.8.1 函数长度[建议] 一个函数的长度控制在 50 行以内。解释： 将过多的逻辑单元混在一个大函数中，易导致难以维护。一个清晰易懂的函数应该完成单一的逻辑单元。复杂的操作应进一步抽取，通过函数的调用来体现流程。 特定算法等不可分割的逻辑允许例外。 示例： 123456789101112131415161718192021222324252627282930313233343536373839404142function syncViewStateOnUserAction() &#123; if (x.checked) &#123; y.checked = true; z.value = ''; &#125; else &#123; y.checked = false; &#125; if (a.value) &#123; warning.innerText = ''; submitButton.disabled = false; &#125; else &#123; warning.innerText = 'Please enter it'; submitButton.disabled = true; &#125;&#125;// 直接阅读该函数会难以明确其主线逻辑，因此下方是一种更合理的表达方式：function syncViewStateOnUserAction() &#123; syncXStateToView(); checkAAvailability();&#125;function syncXStateToView() &#123; y.checked = x.checked; if (x.checked) &#123; z.value = ''; &#125;&#125;function checkAAvailability() &#123; if (a.value) &#123; clearWarnignForA(); &#125; else &#123; displayWarningForAMissing(); &#125;&#125; 3.8.2 参数设计[建议] 一个函数的参数控制在 6 个以内。解释： 除去不定长参数以外，函数具备不同逻辑意义的参数建议控制在 6 个以内，过多参数会导致维护难度增大。 某些情况下，如使用 AMD Loader 的 require 加载多个模块时，其 callback 可能会存在较多参数，因此对函数参数的个数不做强制限制。 [建议] 通过 options 参数传递非数据输入型参数。解释： 有些函数的参数并不是作为算法的输入，而是对算法的某些分支条件判断之用，此类参数建议通过一个 options 参数传递。 如下函数： 12345678910111213/** * 移除某个元素 * * @param &#123;Node&#125; element 需要移除的元素 * @param &#123;boolean&#125; removeEventListeners 是否同时将所有注册在元素上的事件移除 */function removeElement(element, removeEventListeners) &#123; element.parent.removeChild(element); if (removeEventListeners) &#123; element.clearEventListeners(); &#125;&#125; 可以转换为下面的签名： 1234567891011121314/** * 移除某个元素 * * @param &#123;Node&#125; element 需要移除的元素 * @param &#123;Object&#125; options 相关的逻辑配置 * @param &#123;boolean&#125; options.removeEventListeners 是否同时将所有注册在元素上的事件移除 */function removeElement(element, options) &#123; element.parent.removeChild(element); if (options.removeEventListeners) &#123; element.clearEventListeners(); &#125;&#125; 这种模式有几个显著的优势： boolean 型的配置项具备名称，从调用的代码上更易理解其表达的逻辑意义。 当配置项有增长时，无需无休止地增加参数个数，不会出现 removeElement(element, true, false, false, 3) 这样难以理解的调用代码。 当部分配置参数可选时，多个参数的形式非常难处理重载逻辑，而使用一个 options 对象只需判断属性是否存在，实现得以简化。 3.8.3 闭包[建议] 在适当的时候将闭包内大对象置为 null。解释： 在 JavaScript 中，无需特别的关键词就可以使用闭包，一个函数可以任意访问在其定义的作用域外的变量。需要注意的是，函数的作用域是静态的，即在定义时决定，与调用的时机和方式没有任何关系。 闭包会阻止一些变量的垃圾回收，对于较老旧的 JavaScript 引擎，可能导致外部所有变量均无法回收。 首先一个较为明确的结论是，以下内容会影响到闭包内变量的回收： 嵌套的函数中是否有使用该变量。 嵌套的函数中是否有 直接调用eval。 是否使用了 with 表达式。 Chakra、V8 和 SpiderMonkey 将受以上因素的影响，表现出不尽相同又较为相似的回收策略，而 JScript.dll 和 Carakan 则完全没有这方面的优化，会完整保留整个 LexicalEnvironment 中的所有变量绑定，造成一定的内存消耗。 由于对闭包内变量有回收优化策略的 Chakra、V8 和 SpiderMonkey 引擎的行为较为相似，因此可以总结如下，当返回一个函数 fn 时： 如果 fn 的 [[Scope]] 是 ObjectEnvironment（with 表达式生成 ObjectEnvironment，函数和 catch 表达式生成 DeclarativeEnvironment），则： 如果是 V8 引擎，则退出全过程。 如果是 SpiderMonkey，则处理该 ObjectEnvironment 的外层 LexicalEnvironment。 获取当前 LexicalEnvironment 下的所有类型为 Function 的对象，对于每一个 Function 对象，分析其 FunctionBody： 如果 FunctionBody 中含有 直接调用 eval，则退出全过程。 否则得到所有的 Identifier。 对于每一个 Identifier，设其为 name，根据查找变量引用的规则，从 LexicalEnvironment 中找出名称为 name 的绑定 binding。 对 binding 添加 notSwap 属性，其值为 true。 检查当前 LexicalEnvironment 中的每一个变量绑定，如果该绑定有 notSwap 属性且值为 true，则： 如果是 V8 引擎，删除该绑定。 如果是 SpiderMonkey，将该绑定的值设为 undefined，将删除 notSwap 属性。 对于 Chakra 引擎，暂无法得知是按 V8 的模式还是按 SpiderMonkey 的模式进行。 如果有 非常庞大 的对象，且预计会在 老旧的引擎 中执行，则使用闭包时，注意将闭包不需要的对象置为空引用。 [建议] 使用 IIFE 避免 Lift 效应。解释： 在引用函数外部变量时，函数执行时外部变量的值由运行时决定而非定义时，最典型的场景如下： 1234567891011var tasks = [];for (var i = 0; i &lt; 5; i++) &#123; tasks[tasks.length] = function () &#123; console.log('Current cursor is at ' + i); &#125;;&#125;var len = tasks.length;while (len--) &#123; tasks[len]();&#125; 以上代码对 tasks 中的函数的执行均会输出 Current cursor is at 5，往往不符合预期。 此现象称为 Lift 效应 。解决的方式是通过额外加上一层闭包函数，将需要的外部变量作为参数传递来解除变量的绑定关系： 1234567891011121314var tasks = [];for (var i = 0; i &lt; 5; i++) &#123; // 注意有一层额外的闭包 tasks[tasks.length] = (function (i) &#123; return function () &#123; console.log('Current cursor is at ' + i); &#125;; &#125;)(i);&#125;var len = tasks.length;while (len--) &#123; tasks[len]();&#125; 3.8.4 空函数","categories":[{"name":"web前端","slug":"web前端","permalink":"http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"网格布局grid","slug":"HTML5与CSS3-网格布局","date":"2020-06-01T12:08:15.000Z","updated":"2020-06-02T14:12:17.690Z","comments":true,"path":"2020/06/01/HTML5与CSS3-网格布局/","link":"","permalink":"http://yoursite.com/2020/06/01/HTML5%E4%B8%8ECSS3-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80/","excerpt":"","text":"网格布局grid作用在父类上 display : grid grid-template-columns : 设置列数， grid-template-rows : 设置行数 fr单位，注：网格中提供了一个新的单位：fr ( 比例单位 ) repeat()方法 grid-template-areas : 划分区域的 区域必须是矩形 grid-column-gap : 列的间距，grid-row-gap : 行的间距 grid-gap : 复合写法grid-row-gap grid-column-gap justify-items : 子项的水平居中方式 默认 : stretch 默认值，拉伸。表现为水平或垂直填充。 start左对齐 center居中 end右对齐 align-items : 子项的垂直居中方式 默认 : stretch 默认值，拉伸。表现为水平或垂直填充。 start上对齐 center居中 end下对齐 justify-content : 整体网格的水平对齐方式 默认：stretch start 左对齐 end 右对齐 center 居中对齐 space-between 两端对齐 space-around中间距离是两边距离两倍 space-evenly 均匀分布 align-content : 整体网格的垂直对齐方式 与水平对齐方式一致 作用在子项上的 grid-column-start 水平方向上占据的起始位置 grid-column-end 水平方向上占据的结束位置 grid-row-start 垂直方向上占据的起始位置 grid-row-end 垂直方向上占据的结束位置 justify-self 子项在水平方向的位置 algin-self 子项在垂直方向的位置 XMind: ZEN - Trial Version","categories":[{"name":"web前端","slug":"web前端","permalink":"http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"HTML5与CSS3","slug":"HTML5与CSS3","permalink":"http://yoursite.com/tags/HTML5%E4%B8%8ECSS3/"}]}],"categories":[{"name":"web前端","slug":"web前端","permalink":"http://yoursite.com/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"HTML5与CSS3","slug":"HTML5与CSS3","permalink":"http://yoursite.com/tags/HTML5%E4%B8%8ECSS3/"}]}